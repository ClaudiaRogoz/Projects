Merca
Ionel
311CB
function [ N,fa] = eval_interpolator_c(tip, eps)
Pentru evaluarea continua folosim functia : fx(j)=exp(3*cos(x(j)))/(2*pi*besseli(0,3)); si calculam initial pentru cele 1001 puncte generate cu linspace(-pi,pi,1001)) valoarea functiei. Apoi aplicam algoritmi pentru aflarea gradului pentru care polinomul converge cu eroarea dorita eps, pentru fiecare implementare in parte. Lagrange , newton, spline liniar, spline natural , spline tensionat, interpolare trigonometrica. Initial calculam pt cazul 5 si 9 puncte pentru initializarea erorilor e1 si e2. Pentru fiecare mod de interpolare calculam coeficientii polinomului pt gradul 2^k si aflam valoarea polinomului obtinut in cele 1001 puncte si calculam eroarea e=e+(h*((fx(j)-fxp)^2)); j=1:1001 si fxp reprezinta valoarea polinomului in punctul x(j); calculam eroarea atata timp cat diferenta dintre eroarea la pasul p+1 si eroarea la pasul p este mai mare decat eps care reprezinta acuratetea dorita , rezultatul este reprezentat de gradul polinomului pentru care se atinge e2-e1 <eps. Daca eroarea la pasul p+1 este mai mare decat eroarea la pasul p atunci metoda nu converge si returnam inf.Am aplicat acelasi algoritm pentru fiecare mod de interpolare. diferentele ar putea consta in modul de calculare a valorii polinomului in cele 1001 puncte de ex pentru splineuri a trebuit sa caut in ce intervalse afla fiecare valoarea din cele 1001 puncte si am aflat astfel ce spline trebuie folosit.( de fapt am parcurs splineurile si am cautat pentru fiecare spline punctele care convin }. Algoritmii pentru fiecare tip de interpolare i-am luat din biblioteca de pe site. fa reprezinta un vector cu valorile functiei in cele 1001 puncte pentru care converge necesar pentru desenarea graficului.
Cele mai bune metode sunt: interpolare cu spline natural si tensionat dar si interpolare trigonometrica, grafic apropiindu-se cel mai mult de graficul original, aceste metode converg pentru valori foarte mici ale lui eps de ordinul 10e-7 deci sunt cele mai exacte. Lagrange si Newton nu aproximeaza foarte bine intorcand inf pt valori mai mici de 0.1 ale lui eps 
function [ N,fa] = eval_interpolator_d(tip, eps)
Aproximarea discreta difera de aproximarea continua prin faptul ca nu cunoastem valoarea functie decat intr-un nr finit de puncte in cazul nostru 300 de puncte care reprezinta suportul interpolarii. 
Generam un nr de 2^k+1 puncte k=2:8 pentru ca nr maxim de puncte este 257 pentru ca nu cunoastem functia in 2^9+1 puncte. Punctele generate le-am aproximat prin adaugare cu x1=linspace(1701,2001,2^k+1)  si x1=ceil(x1) si am cautat in vectorul x indicele valorii x1(j) si apoi fx(indice) reprezinta valoarea functiei. aplicam algorimul de calcul al coeficientilor polinomului de interpolare si am calculat apoi valoarea polinomului de interpolare in cele 300 de puncte. 
function A=test(eps)
Retinem in matricea A pe linia 1 valoarea gradului pentru continuu si pe linia 2 valoarea gradului pentru discret apeland functiile succesiv pentru fiecare mod de interpolare.
function test_grafic(eps)
folosind subplot am generat 2 grafice unul pentru aproximare continua si celalalt pentru aproximare discreta.  apoi am dat plot(x,fx,'culoare') urmat de hold on pentru a desena in acelasi grafic, x reprezinta cele 1001 puncte generate cu linspace(-pi,pi,1001) si fx valoarea celor 1001 puncte pentru fiecare polinom de interpolare si valoare functiei. 
Pentru aproximare discreta am luat cele 300 de puncte si 300 de valori din fisierul sunspot.dat si am reprezentat grafic plot (A(:,1),A(:,2),'culoare') si pentru fiecae polinom de interpolare plot ( A(:,1),fx,'culoare') fx valoare polinomului in cele 300 puncte.
